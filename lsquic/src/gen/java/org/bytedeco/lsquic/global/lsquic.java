// Targeted by JavaCPP version 1.5.5-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.lsquic.global;

import org.bytedeco.lsquic.*;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

public class lsquic extends org.bytedeco.lsquic.presets.lsquic {
    static { Loader.load(); }

// Parsed from <lsquic.h>

/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE. */
// #ifndef __LSQUIC_H__
// #define __LSQUIC_H__

/**
 * \file
 * public API for using liblsquic is defined in this file.
 *
 */

// #include <stdarg.h>
// #include <lsquic_types.h>
// #ifndef WIN32
// #include <sys/uio.h>
// #include <time.h>
// #else
// #include <vc_compat.h>
// Targeting ../sockaddr.java



// #ifdef __cplusplus
// #endif

public static final int LSQUIC_MAJOR_VERSION = 2;
public static final int LSQUIC_MINOR_VERSION = 27;
public static final int LSQUIC_PATCH_VERSION = 5;

/**
 * Engine flags:
 */

/** Server mode */
public static final int LSENG_SERVER = (1 << 0);

/** Use HTTP behavior */
public static final int LSENG_HTTP =  (1 << 1);

public static final int LSENG_HTTP_SERVER = (LSENG_SERVER|LSENG_HTTP);

/**
 * This is a list of QUIC versions that we know of.  List of supported
 * versions is in LSQUIC_SUPPORTED_VERSIONS.
 */
/** enum lsquic_version */
public static final int
    /**
     * Q043.  Support for processing PRIORITY frames.  Since this library
     * has supported PRIORITY frames from the beginning, this version is
     * exactly the same as LSQVER_042.
     */
    LSQVER_043 = 0,

    /**
     * Q046.  Use IETF Draft-17 compatible packet headers.
     */
    LSQVER_046 = 1,

    /**
     * Q050.  Variable-length QUIC server connection IDs.  Use CRYPTO frames
     * for handshake.  IETF header format matching invariants-06.  Packet
     * number encryption.  Initial packets are obfuscated.
     */
    LSQVER_050 = 2;

// #if LSQUIC_USE_Q098
// #else
public static final int LSQUIC_EXPERIMENTAL_Q098 = 0;
// #endif

    /**
     * IETF QUIC Draft-27
     */
public static final int
    LSQVER_ID27 = 3,

    /**
     * IETF QUIC Draft-28; this version is deprecated.
     */
    LSQVER_ID28 = 4,

    /**
     * IETF QUIC Draft-29
     */
    LSQVER_ID29 = 5,

    /**
     * IETF QUIC Draft-32
     */
    LSQVER_ID32 = 6,

    /**
     * Special version to trigger version negotiation.
     * [draft-ietf-quic-transport-11], Section 3.
     */
    LSQVER_VERNEG = 7,

    N_LSQVER = 8;

/**
 * We currently support versions 43, 46, 50, Draft-27, Draft-28, Draft-29,
 * and Draft-32.
 * @see lsquic_version
 */
public static final int LSQUIC_SUPPORTED_VERSIONS = ((1 << N_LSQVER) - 1);

/**
 * List of versions in which the server never includes CID in short packets.
 */
public static final int LSQUIC_FORCED_TCID0_VERSIONS = ((1 << LSQVER_046)|(1 << LSQVER_050));

public static final int LSQUIC_EXPERIMENTAL_VERSIONS = ( 
                            (1 << LSQVER_VERNEG) | LSQUIC_EXPERIMENTAL_Q098);

public static final int LSQUIC_DEPRECATED_VERSIONS = ((1 << LSQVER_ID27) | (1 << LSQVER_ID28));

public static final int LSQUIC_GQUIC_HEADER_VERSIONS = (1 << LSQVER_043);

public static final int LSQUIC_IETF_VERSIONS = ((1 << LSQVER_ID27) | (1 << LSQVER_ID28) 
                          | (1 << LSQVER_ID29) 
                          | (1 << LSQVER_ID32) | (1 << LSQVER_VERNEG));

public static final int LSQUIC_IETF_DRAFT_VERSIONS = ((1 << LSQVER_ID27) | (1 << LSQVER_ID28) 
                                  | (1 << LSQVER_ID29) 
                                  | (1 << LSQVER_ID32) | (1 << LSQVER_VERNEG));

/** enum lsquic_hsk_status */
public static final int
    /**
     * The handshake failed.
     */
    LSQ_HSK_FAIL = 0,
    /**
     * The handshake succeeded without session resumption.
     */
    LSQ_HSK_OK = 1,
    /**
     * The handshake succeeded with session resumption.
     */
    LSQ_HSK_RESUMED_OK = 2,
    /**
     * Session resumption failed.  Retry the connection without session
     * resumption.
     */
    LSQ_HSK_RESUMED_FAIL = 3;
// Targeting ../lsquic_stream_if.java


// Targeting ../ssl_ctx_st.java


// Targeting ../ssl_st.java


// Targeting ../lsxpack_header.java



/**
 * QUIC engine in server mode needs access to certificates.  This is
 * accomplished by providing a callback and a context to the engine
 * constructor.
 */

/* `sni' may be NULL if engine is not HTTP mode and client TLS transport
 * parameters did not include the SNI.
 */

/**
 * Minimum flow control window is set to 16 KB for both client and server.
 * This means we can send up to this amount of data before handshake gets
 * completed.
 */
public static final int LSQUIC_MIN_FCW =             (16 * 1024);

/* Each LSQUIC_DF_* value corresponds to es_* entry in
 * lsquic_engine_settings below.
 */

/**
 * By default, deprecated and experimental versions are not included.
 */
public static final int LSQUIC_DF_VERSIONS =         (LSQUIC_SUPPORTED_VERSIONS & 
                                            ~LSQUIC_DEPRECATED_VERSIONS & 
                                            ~LSQUIC_EXPERIMENTAL_VERSIONS);

public static final int LSQUIC_DF_CFCW_SERVER =      (3 * 1024 * 1024 / 2);
public static final int LSQUIC_DF_CFCW_CLIENT =      (15 * 1024 * 1024);
public static final int LSQUIC_DF_SFCW_SERVER =      (1 * 1024 * 1024);
public static final int LSQUIC_DF_SFCW_CLIENT =      (6 * 1024 * 1024);
public static final int LSQUIC_DF_MAX_STREAMS_IN =   100;

/* IQUIC uses different names for these: */
public static final int LSQUIC_DF_INIT_MAX_DATA_SERVER = LSQUIC_DF_CFCW_SERVER;
public static final int LSQUIC_DF_INIT_MAX_DATA_CLIENT = LSQUIC_DF_CFCW_CLIENT;
public static final int LSQUIC_DF_INIT_MAX_STREAM_DATA_BIDI_REMOTE_SERVER = LSQUIC_DF_SFCW_SERVER;
public static final int LSQUIC_DF_INIT_MAX_STREAM_DATA_BIDI_LOCAL_SERVER = 0;
public static final int LSQUIC_DF_INIT_MAX_STREAM_DATA_BIDI_REMOTE_CLIENT = 0;
public static final int LSQUIC_DF_INIT_MAX_STREAM_DATA_BIDI_LOCAL_CLIENT = LSQUIC_DF_SFCW_CLIENT;
public static final int LSQUIC_DF_INIT_MAX_STREAMS_BIDI = LSQUIC_DF_MAX_STREAMS_IN;
public static final int LSQUIC_DF_INIT_MAX_STREAMS_UNI_CLIENT = 100;
public static final int LSQUIC_DF_INIT_MAX_STREAMS_UNI_SERVER = 3;
/* XXX What's a good value here? */
public static final int LSQUIC_DF_INIT_MAX_STREAM_DATA_UNI_CLIENT =   (32 * 1024);
public static final int LSQUIC_DF_INIT_MAX_STREAM_DATA_UNI_SERVER =   (12 * 1024);

/**
 * Default idle connection time in seconds.
 */
public static final int LSQUIC_DF_IDLE_TIMEOUT = 30;

/**
 * Default ping period in seconds.
 */
public static final int LSQUIC_DF_PING_PERIOD = 15;

/**
 * Default handshake timeout in microseconds.
 */
public static final int LSQUIC_DF_HANDSHAKE_TO =     (10 * 1000 * 1000);

public static final int LSQUIC_DF_IDLE_CONN_TO =     (LSQUIC_DF_IDLE_TIMEOUT * 1000 * 1000);
public static final int LSQUIC_DF_SILENT_CLOSE =     1;

/** Default value of maximum header list size.  If set to non-zero value,
 *  SETTINGS_MAX_HEADER_LIST_SIZE will be sent to peer after handshake is
 *  completed (assuming the peer supports this setting frame type).
 */
public static final int LSQUIC_DF_MAX_HEADER_LIST_SIZE = 0;

/** Default value of UAID (user-agent ID). */
public static final String LSQUIC_DF_UA =               "LSQUIC";

public static final int LSQUIC_DF_STTL =               86400;
public static final int LSQUIC_DF_MAX_INCHOATE =     (1 * 1000 * 1000);
/** Do not use NSTP by default */
public static final int LSQUIC_DF_SUPPORT_NSTP =     0;
/** TODO: IETF QUIC clients do not support push */
public static final int LSQUIC_DF_SUPPORT_PUSH =         1;
public static final int LSQUIC_DF_SUPPORT_TCID0 =    1;
/** By default, LSQUIC ignores Public Reset packets. */
public static final int LSQUIC_DF_HONOR_PRST =       0;

/**
 * By default, LSQUIC will not send Public Reset packets in response to
 * packets that specify unknown connections.
 */
public static final int LSQUIC_DF_SEND_PRST =        0;

/** By default, infinite loop checks are turned on */
public static final int LSQUIC_DF_PROGRESS_CHECK =    1000;

/** By default, read/write events are dispatched in a loop */
public static final int LSQUIC_DF_RW_ONCE =           0;

/** By default, the threshold is not enabled */
public static final int LSQUIC_DF_PROC_TIME_THRESH =  0;

/** By default, packets are paced */
public static final int LSQUIC_DF_PACE_PACKETS =      1;

/** Default clock granularity is 1000 microseconds */
public static final int LSQUIC_DF_CLOCK_GRANULARITY =      1000;

/** The default value is 8 for simplicity */
public static final int LSQUIC_DF_SCID_LEN = 8;

/** The default value is 60 CIDs per minute */
public static final int LSQUIC_DF_SCID_ISS_RATE =   60;

public static final int LSQUIC_DF_QPACK_DEC_MAX_BLOCKED = 100;
public static final int LSQUIC_DF_QPACK_DEC_MAX_SIZE = 4096;
public static final int LSQUIC_DF_QPACK_ENC_MAX_BLOCKED = 100;
public static final int LSQUIC_DF_QPACK_ENC_MAX_SIZE = 4096;

/* By default, QPACK experiments are turned off */
public static final int LSQUIC_DF_QPACK_EXPERIMENT = 0;

/** ECN is disabled by default */
public static final int LSQUIC_DF_ECN = 0;

/** Allow migration by default */
public static final int LSQUIC_DF_ALLOW_MIGRATION = 1;

/** Use QL loss bits by default */
public static final int LSQUIC_DF_QL_BITS = 2;

/** Turn spin bit on by default */
public static final int LSQUIC_DF_SPIN = 1;

/** Turn on delayed ACKs extension by default */
public static final int LSQUIC_DF_DELAYED_ACKS = 1;

/**
 * Defaults for the Packet Tolerance PID Controller (PTPC) used by the
 * Delayed ACKs extension:
 */
public static final int LSQUIC_DF_PTPC_PERIODICITY = 3;
public static final int LSQUIC_DF_PTPC_MAX_PACKTOL = 150;
public static final int LSQUIC_DF_PTPC_DYN_TARGET = 1;
public static final double LSQUIC_DF_PTPC_TARGET = 1.0;
public static final double LSQUIC_DF_PTPC_PROP_GAIN = 0.8;
public static final double LSQUIC_DF_PTPC_INT_GAIN = 0.35;
public static final double LSQUIC_DF_PTPC_ERR_THRESH = 0.05;
public static final double LSQUIC_DF_PTPC_ERR_DIVISOR = 0.05;

/** Turn on timestamp extension by default */
public static final int LSQUIC_DF_TIMESTAMPS = 1;

/* Use Adaptive CC by default */
public static final int LSQUIC_DF_CC_ALGO = 3;

/* Default value of the CC RTT threshold is 1.5 ms */
public static final int LSQUIC_DF_CC_RTT_THRESH = 1500;

/** Turn off datagram extension by default */
public static final int LSQUIC_DF_DATAGRAMS = 0;

/** Assume optimistic NAT by default. */
public static final int LSQUIC_DF_OPTIMISTIC_NAT = 1;

/** Turn on Extensible HTTP Priorities by default. */
public static final int LSQUIC_DF_EXT_HTTP_PRIO = 1;

/** By default, incoming packet size is not limited. */
public static final int LSQUIC_DF_MAX_UDP_PAYLOAD_SIZE_RX = 0;

/**
 * By default, greasing the QUIC bit is enabled (if peer sent
 * the "grease_quic_bit" transport parameter).
 */
public static final int LSQUIC_DF_GREASE_QUIC_BIT = 1;

/** By default, DPLPMTUD is enabled */
public static final int LSQUIC_DF_DPLPMTUD = 1;

/** By default, this value is left up to the engine. */
public static final int LSQUIC_DF_BASE_PLPMTU = 0;

/** By default, this value is left up to the engine. */
public static final int LSQUIC_DF_MAX_PLPMTU = 0;

/** By default, drop no-progress connections after 60 seconds on the server */
public static final int LSQUIC_DF_NOPROGRESS_TIMEOUT_SERVER = 60;

/** By default, do not use no-progress timeout on the client */
public static final int LSQUIC_DF_NOPROGRESS_TIMEOUT_CLIENT = 0;

/** By default, we use the minimum timer of 1000 milliseconds */
public static final int LSQUIC_DF_MTU_PROBE_TIMER = 1000;

/** By default, calling on_close() is not delayed */
public static final int LSQUIC_DF_DELAY_ONCLOSE = 0;

/**
 * By default, maximum batch size is not specified, leaving it up to the
 * library.
 */
public static final int LSQUIC_DF_MAX_BATCH_SIZE = 0;
// Targeting ../lsquic_engine_settings.java



/* Initialize `settings' to default values */
public static native void lsquic_engine_init_settings(lsquic_engine_settings arg0,
                             @Cast("unsigned") int lsquic_engine_flags);

/**
 * Check settings for errors.
 *
 * @param   settings    Settings struct.
 *
 * @param   flags       Engine flags.
 *
 * @param   err_buf     Optional pointer to buffer into which error string
 *                      is written.
 <p>
 * @param   err_buf_sz  Size of err_buf.  No more than this number of bytes
 *                      will be written to err_buf, including the NUL byte.
 *
 * \retval  0   Settings have no errors.
 * \retval -1   There are errors in settings.
 */
public static native int lsquic_engine_check_settings(@Const lsquic_engine_settings settings,
                              @Cast("unsigned") int lsquic_engine_flags,
                              @Cast("char*") BytePointer err_buf, @Cast("size_t") long err_buf_sz);
public static native int lsquic_engine_check_settings(@Const lsquic_engine_settings settings,
                              @Cast("unsigned") int lsquic_engine_flags,
                              @Cast("char*") ByteBuffer err_buf, @Cast("size_t") long err_buf_sz);
public static native int lsquic_engine_check_settings(@Const lsquic_engine_settings settings,
                              @Cast("unsigned") int lsquic_engine_flags,
                              @Cast("char*") byte[] err_buf, @Cast("size_t") long err_buf_sz);
// Targeting ../lsquic_out_spec.java


// Targeting ../lsquic_packets_out_f.java


// Targeting ../lsquic_shared_hash_if.java


// Targeting ../lsquic_packout_mem_if.java


// Targeting ../lsquic_cids_update_f.java


// Targeting ../stack_st_X509.java



/** enum lsquic_hsi_flag */
public static final int
    /**
     * Turn HTTP/1.x mode on or off.  In this mode, decoded name and value
     * pair are separated by ": " and "\r\n" is appended to the end of the
     * string.  By default, this mode is off.
     */
    LSQUIC_HSI_HTTP1X          = 1 << 1,
    /** Include name hash into lsxpack_header */
    LSQUIC_HSI_HASH_NAME       = 1 << 2,
    /** Include nameval hash into lsxpack_header */
    LSQUIC_HSI_HASH_NAMEVAL    = 1 << 3;
// Targeting ../lsquic_hset_if.java


// Targeting ../lsquic_engine_api.java



/**
 * Create new engine.
 *
 * @param   lsquic_engine_flags     A bitmask of \ref LSENG_SERVER and
 *                                  \ref LSENG_HTTP
 *
 * @param   api                     Required parameter that specifies
 *                                    various callbacks.
 *
 * The engine can be instantiated either in server mode (when LSENG_SERVER
 * is set) or client mode.  If you need both server and client in your
 * program, create two engines (or as many as you'd like).
 */
public static native lsquic_engine_t lsquic_engine_new(@Cast("unsigned") int lsquic_engine_flags,
                   @Const lsquic_engine_api api);

/**
 * Create a client connection to peer identified by {@code peer_ctx'.
 *
 * To let the engine specify QUIC version, use N_LSQVER.  If session resumption
 * information is supplied, version is picked from there instead.
 *
 * If }base_plpmtu' is set to zero, it is selected based on the
 * engine settings, QUIC version, and IP version.
 */
public static native lsquic_conn_t lsquic_engine_connect(lsquic_engine_t arg0, @Cast("lsquic_version") int arg1,
                       @Const sockaddr local_sa,
                       @Const sockaddr peer_sa,
                       Pointer peer_ctx, lsquic_conn_ctx_t conn_ctx,
                       @Cast("const char*") BytePointer hostname, @Cast("unsigned short") short base_plpmtu,
                       @Cast("const unsigned char*") BytePointer sess_resume, @Cast("size_t") long sess_resume_len,
                       @Cast("const unsigned char*") BytePointer token, @Cast("size_t") long token_sz);
public static native lsquic_conn_t lsquic_engine_connect(lsquic_engine_t arg0, @Cast("lsquic_version") int arg1,
                       @Const sockaddr local_sa,
                       @Const sockaddr peer_sa,
                       Pointer peer_ctx, lsquic_conn_ctx_t conn_ctx,
                       String hostname, @Cast("unsigned short") short base_plpmtu,
                       @Cast("const unsigned char*") ByteBuffer sess_resume, @Cast("size_t") long sess_resume_len,
                       @Cast("const unsigned char*") ByteBuffer token, @Cast("size_t") long token_sz);
public static native lsquic_conn_t lsquic_engine_connect(lsquic_engine_t arg0, @Cast("lsquic_version") int arg1,
                       @Const sockaddr local_sa,
                       @Const sockaddr peer_sa,
                       Pointer peer_ctx, lsquic_conn_ctx_t conn_ctx,
                       @Cast("const char*") BytePointer hostname, @Cast("unsigned short") short base_plpmtu,
                       @Cast("const unsigned char*") byte[] sess_resume, @Cast("size_t") long sess_resume_len,
                       @Cast("const unsigned char*") byte[] token, @Cast("size_t") long token_sz);
public static native lsquic_conn_t lsquic_engine_connect(lsquic_engine_t arg0, @Cast("lsquic_version") int arg1,
                       @Const sockaddr local_sa,
                       @Const sockaddr peer_sa,
                       Pointer peer_ctx, lsquic_conn_ctx_t conn_ctx,
                       String hostname, @Cast("unsigned short") short base_plpmtu,
                       @Cast("const unsigned char*") BytePointer sess_resume, @Cast("size_t") long sess_resume_len,
                       @Cast("const unsigned char*") BytePointer token, @Cast("size_t") long token_sz);
public static native lsquic_conn_t lsquic_engine_connect(lsquic_engine_t arg0, @Cast("lsquic_version") int arg1,
                       @Const sockaddr local_sa,
                       @Const sockaddr peer_sa,
                       Pointer peer_ctx, lsquic_conn_ctx_t conn_ctx,
                       @Cast("const char*") BytePointer hostname, @Cast("unsigned short") short base_plpmtu,
                       @Cast("const unsigned char*") ByteBuffer sess_resume, @Cast("size_t") long sess_resume_len,
                       @Cast("const unsigned char*") ByteBuffer token, @Cast("size_t") long token_sz);
public static native lsquic_conn_t lsquic_engine_connect(lsquic_engine_t arg0, @Cast("lsquic_version") int arg1,
                       @Const sockaddr local_sa,
                       @Const sockaddr peer_sa,
                       Pointer peer_ctx, lsquic_conn_ctx_t conn_ctx,
                       String hostname, @Cast("unsigned short") short base_plpmtu,
                       @Cast("const unsigned char*") byte[] sess_resume, @Cast("size_t") long sess_resume_len,
                       @Cast("const unsigned char*") byte[] token, @Cast("size_t") long token_sz);

/**
 * Pass incoming packet to the QUIC engine.  This function can be called
 * more than once in a row.  After you add one or more packets, call
 * lsquic_engine_process_conns() to schedule output, if any.
 *
 * \retval  0   Packet was processed by a real connection.
 *
 * \retval  1   Packet was handled successfully, but not by a connection.
 *              This may happen with version negotiation and public reset
 *              packets as well as some packets that may be ignored.
 *
 * \retval -1   An error occurred.  Possible reasons are failure to allocate
 *              memory and invalid @param sa_local in client mode.
 */
public static native int lsquic_engine_packet_in(lsquic_engine_t arg0,
        @Cast("const unsigned char*") BytePointer packet_in_data, @Cast("size_t") long packet_in_size,
        @Const sockaddr sa_local, @Const sockaddr sa_peer,
        Pointer peer_ctx, int ecn);
public static native int lsquic_engine_packet_in(lsquic_engine_t arg0,
        @Cast("const unsigned char*") ByteBuffer packet_in_data, @Cast("size_t") long packet_in_size,
        @Const sockaddr sa_local, @Const sockaddr sa_peer,
        Pointer peer_ctx, int ecn);
public static native int lsquic_engine_packet_in(lsquic_engine_t arg0,
        @Cast("const unsigned char*") byte[] packet_in_data, @Cast("size_t") long packet_in_size,
        @Const sockaddr sa_local, @Const sockaddr sa_peer,
        Pointer peer_ctx, int ecn);

/**
 * Process tickable connections.  This function must be called often enough so
 * that packets and connections do not expire.
 */
public static native void lsquic_engine_process_conns(lsquic_engine_t engine);

/**
 * Returns true if engine has some unsent packets.  This happens if
 * \ref ea_packets_out() could not send everything out or if processing
 * deadline was exceeded (see \ref es_proc_time_thresh).
 */
public static native int lsquic_engine_has_unsent_packets(lsquic_engine_t engine);

/**
 * Send out as many unsent packets as possibe: until we are out of unsent
 * packets or until \ref ea_packets_out() fails.
 *
 * If \ref ea_packets_out() does fail cannot send all packets, this
 * function must be called to signify that sending of packets is possible
 * again.
 */
public static native void lsquic_engine_send_unsent_packets(lsquic_engine_t engine);

/**
 * Destroy engine and all connections and streams in it and free all
 * memory associated with this engine.
 */
public static native void lsquic_engine_destroy(lsquic_engine_t arg0);

/** Return max allowed outbound streams less current outbound streams. */
public static native @Cast("unsigned") int lsquic_conn_n_avail_streams(@Const lsquic_conn_t arg0);

/**
 * Create a new request stream.  This causes \ref on_new_stream() callback
 * to be called.  If creating more requests is not permitted at the moment
 * (due to number of concurrent streams limit), stream creation is registered
 * as "pending" and the stream is created later when number of streams dips
 * under the limit again.  Any number of pending streams can be created.
 * Use \ref lsquic_conn_n_pending_streams() and
 * \ref lsquic_conn_cancel_pending_streams() to manage pending streams.
 *
 * If connection is going away, \ref on_new_stream() is called with the
 * stream parameter set to NULL.
 */
public static native void lsquic_conn_make_stream(lsquic_conn_t arg0);

/** Return number of delayed streams currently pending */
public static native @Cast("unsigned") int lsquic_conn_n_pending_streams(@Const lsquic_conn_t arg0);

/** Cancel {@code n' pending streams.  Returns new number of pending streams. */
public static native @Cast("unsigned") int lsquic_conn_cancel_pending_streams(lsquic_conn_t arg0, @Cast("unsigned") int n);

/**
 * Mark connection as going away: send GOAWAY frame and do not accept
 * any more incoming streams, nor generate streams of our own.
 *
 * Only applicable to HTTP/3 and GQUIC connections.  Otherwise a no-op.
 */
public static native void lsquic_conn_going_away(lsquic_conn_t arg0);

/**
 * This forces connection close.  on_conn_closed and on_close callbacks
 * will be called.
 */
public static native void lsquic_conn_close(lsquic_conn_t arg0);

/**
 * Set whether you want to read from stream.  If @param is_want is true,
 * \ref on_read() will be called when there is readable data in the
 * stream.  If @param is false, \ref on_read() will not be called.
 *
 * Returns previous value of this flag.
 */
public static native int lsquic_stream_wantread(lsquic_stream_t s, int is_want);

/**
 * Read up to @param len bytes from stream into @param buf.  Returns number
 * of bytes read or -1 on error, in which case errno is set.  Possible
 * errno values:
 *
 *  EBADF           The stream is closed.
 *  ECONNRESET      The stream has been reset.
 *  EWOULDBLOCK     There is no data to be read.
 *
 * Return value of zero indicates EOF.
 */
public static native @Cast("ssize_t") long lsquic_stream_read(lsquic_stream_t s, Pointer buf, @Cast("size_t") long len);

/**
 * Similar to \ref lsquic_stream_read(), but reads data into @param vec.
 */
public static native @Cast("ssize_t") long lsquic_stream_readv(lsquic_stream_t s, @Const iovec vec, int iovcnt);
// Targeting ../Readf_Pointer_BytePointer_long_int.java


public static native @Cast("ssize_t") long lsquic_stream_readf(lsquic_stream_t s,
    Readf_Pointer_BytePointer_long_int readf,
    Pointer ctx);
// Targeting ../Readf_Pointer_ByteBuffer_long_int.java


public static native @Cast("ssize_t") long lsquic_stream_readf(lsquic_stream_t s,
    Readf_Pointer_ByteBuffer_long_int readf,
    Pointer ctx);
// Targeting ../Readf_Pointer_byte___long_int.java


public static native @Cast("ssize_t") long lsquic_stream_readf(lsquic_stream_t s,
    Readf_Pointer_byte___long_int readf,
    Pointer ctx);

/**
 * Set whether you want to write to stream.  If @param is_want is true,
 * \ref on_write() will be called when it is possible to write data to
 * the stream.  If @param is false, \ref on_write() will not be called.
 *
 * Returns previous value of this flag.
 */
public static native int lsquic_stream_wantwrite(lsquic_stream_t s, int is_want);

/**
 * Write {@code len' bytes to the stream.  Returns number of bytes written, which
 * may be smaller that }len'.
 *
 * A negative return value indicates a serious error (the library is likely
 * to have aborted the connection because of it).
 */
public static native @Cast("ssize_t") long lsquic_stream_write(lsquic_stream_t s, @Const Pointer buf, @Cast("size_t") long len);

/**
 * Like \ref lsquic_stream_write(), but read data from @param vec.
 */
public static native @Cast("ssize_t") long lsquic_stream_writev(lsquic_stream_t s, @Const iovec vec, int count);
// Targeting ../Preadv_Pointer_iovec_int.java


public static native @Cast("ssize_t") long lsquic_stream_pwritev(lsquic_stream_t s,
    Preadv_Pointer_iovec_int preadv,
    Pointer user_data, @Cast("size_t") long n_to_write);
// Targeting ../lsquic_reader.java



/**
 * Write to stream using \ref lsquic_reader.  This is the most generic of
 * the write functions -- \ref lsquic_stream_write() and
 * \ref lsquic_stream_writev() utilize the same mechanism.
 *
 * \retval Number of bytes written or -1 on error.
 */
public static native @Cast("ssize_t") long lsquic_stream_writef(lsquic_stream_t arg0, lsquic_reader arg1);

/**
 * Flush any buffered data.  This triggers packetizing even a single byte
 * into a separate frame.  Flushing a closed stream is an error.
 *
 * \retval  0   Success
 * \retval -1   Failure
 */
public static native int lsquic_stream_flush(lsquic_stream_t s);
// Targeting ../lsquic_http_headers.java



/**
 * Send headers in @param headers.  This function must be called before
 * writing to the stream.  The value of @param eos is ignored in IETF QUIC.
 */
public static native int lsquic_stream_send_headers(lsquic_stream_t s,
                               @Const lsquic_http_headers_t headers, int eos);

/**
 * Get header set associated with the stream.  The header set is created by
 * \ref hsi_create_header_set() callback.  After this call, the ownership of
 * the header set is transferred to the caller.
 *
 * This call must precede calls to \ref lsquic_stream_read() and
 * \ref lsquic_stream_readv().
 *
 * If the optional header set interface (\ref ea_hsi_if) is not specified,
 * this function returns NULL.
 */
public static native Pointer lsquic_stream_get_hset(lsquic_stream_t arg0);

/**
 * A server may push a stream.  This call creates a new stream in reference
 * to stream {@code s'.  It will behave as if the client made a request: it will
 * trigger on_new_stream() event and it can be used as a regular client-
 * initiated stream.
 *
 * }hdr_set' must be set.  It is passed as-is to \lsquic_stream_get_hset.
 *
 * \retval  0   Stream pushed successfully.
 * \retval  1   Stream push failed because it is disabled or because we hit
 *                stream limit or connection is going away.
 * \retval -1   Stream push failed because of an internal error.
 */
public static native int lsquic_conn_push_stream(lsquic_conn_t c, Pointer hdr_set, lsquic_stream_t s,
    @Const lsquic_http_headers_t headers);

/**
 * Only makes sense in server mode: the client cannot push a stream and this
 * function always returns false in client mode.
 */
public static native int lsquic_conn_is_push_enabled(lsquic_conn_t arg0);

/** Possible values for how are 0, 1, and 2.  See shutdown(2). */
public static native int lsquic_stream_shutdown(lsquic_stream_t s, int how);

public static native int lsquic_stream_close(lsquic_stream_t s);

/**
 * Return true if peer has not ACKed all data written to the stream.  This
 * includes both packetized and buffered data.
 */
public static native int lsquic_stream_has_unacked_data(lsquic_stream_t s);

/**
 * Get certificate chain returned by the server.  This can be used for
 * server certificate verification.
 *
 * The caller releases the stack using sk_X509_free().
 */
public static native stack_st_X509 lsquic_conn_get_server_cert_chain(lsquic_conn_t arg0);

/** Returns ID of the stream */
public static native @ByVal lsquic_stream_id_t lsquic_stream_id(@Const lsquic_stream_t s);

/**
 * Returns stream ctx associated with the stream.  (The context is what
 * is returned by \ref on_new_stream callback).
 */
public static native lsquic_stream_ctx_t lsquic_stream_get_ctx(@Const lsquic_stream_t s);

/** Returns true if this is a pushed stream */
public static native int lsquic_stream_is_pushed(@Const lsquic_stream_t s);

/**
 * Returns true if this stream was rejected, false otherwise.  Use this as
 * an aid to distinguish between errors.
 */
public static native int lsquic_stream_is_rejected(@Const lsquic_stream_t s);

/**
 * Refuse pushed stream.  Call it from \ref on_new_stream.
 *
 * No need to call lsquic_stream_close() after this.  on_close will be called.
 *
 * @see lsquic_stream_is_pushed
 */
public static native int lsquic_stream_refuse_push(lsquic_stream_t s);

/**
 * Get information associated with pushed stream:
 *
 * @param ref_stream_id   Stream ID in response to which push promise was
 *                            sent.
 * @param hdr_set         Header set.  This object was passed to or generated
 *                            by \ref lsquic_conn_push_stream().
 *
 * \retval   0  Success.
 * \retval  -1  This is not a pushed stream.
 */
public static native int lsquic_stream_push_info(@Const lsquic_stream_t arg0,
                         lsquic_stream_id_t ref_stream_id, @Cast("void**") PointerPointer hdr_set);
public static native int lsquic_stream_push_info(@Const lsquic_stream_t arg0,
                         lsquic_stream_id_t ref_stream_id, @Cast("void**") @ByPtrPtr Pointer hdr_set);

/** Return current priority of the stream */
public static native @Cast("unsigned") int lsquic_stream_priority(@Const lsquic_stream_t s);

/**
 * Set stream priority.  Valid priority values are 1 through 256, inclusive.
 * Lower value means higher priority.
 *
 * \retval   0  Success.
 * \retval  -1  Priority value is invalid.
 */
public static native int lsquic_stream_set_priority(lsquic_stream_t s, @Cast("unsigned") int priority);

/*
 * Definitions for Extensible HTTP Priorities:
 * https://tools.ietf.org/html/draft-ietf-httpbis-priority-01
 */
/* This is maximum *value* -- but it's the lowest *priority* */
public static final int LSQUIC_MAX_HTTP_URGENCY = 7;
public static final int LSQUIC_DEF_HTTP_URGENCY = 3;
public static final int LSQUIC_DEF_HTTP_INCREMENTAL = 0;
// Targeting ../lsquic_ext_http_prio.java



/**
 * Get Extensible HTTP Priorities associated with the stream.
 *
 * Returns zero on success of a negative value on failure.  A failure occurs
 * if this is not an HTTP/3 stream or if Extensible HTTP Priorities haven't
 * been enabled.  See \ref es_ext_http_prio.
 */
public static native int lsquic_stream_get_http_prio(lsquic_stream_t arg0, lsquic_ext_http_prio arg1);

/**
 * Set Extensible HTTP Priorities of the stream.
 *
 * Returns zero on success of a negative value on failure.  A failure occurs
 * if some internal error occured or if this is not an HTTP/3 stream or if
 * Extensible HTTP Priorities haven't been enabled.  See \ref es_ext_http_prio.
 */
public static native int lsquic_stream_set_http_prio(lsquic_stream_t arg0,
                                        @Const lsquic_ext_http_prio arg1);

/**
 * Get a pointer to the connection object.  Use it with lsquic_conn_*
 * functions.
 */
public static native lsquic_conn_t lsquic_stream_conn(@Const lsquic_stream_t s);

/** Get connection ID */
public static native @Const lsquic_cid_t lsquic_conn_id(@Const lsquic_conn_t c);

/** Get pointer to the engine */
public static native lsquic_engine_t lsquic_conn_get_engine(lsquic_conn_t c);

public static native int lsquic_conn_get_sockaddr(lsquic_conn_t c,
                @Cast("const sockaddr**") PointerPointer local, @Cast("const sockaddr**") PointerPointer peer);
public static native int lsquic_conn_get_sockaddr(lsquic_conn_t c,
                @Const @ByPtrPtr sockaddr local, @Const @ByPtrPtr sockaddr peer);

/* Returns previous value */
public static native int lsquic_conn_want_datagram_write(lsquic_conn_t arg0, int is_want);

/* Get minimum datagram size.  By default, this value is zero. */
public static native @Cast("size_t") long lsquic_conn_get_min_datagram_size(lsquic_conn_t arg0);

/* Set minimum datagram size.  This is the minumum value of the buffer passed
 * to the on_dg_write() callback.
 */
public static native int lsquic_conn_set_min_datagram_size(lsquic_conn_t arg0, @Cast("size_t") long sz);
// Targeting ../lsquic_logger_if.java



/**
 * Enumerate timestamp styles supported by LSQUIC logger mechanism.
 */
/** enum lsquic_logger_timestamp_style */
public static final int
    /**
     * No timestamp is generated.
     */
    LLTS_NONE = 0,

    /**
     * The timestamp consists of 24 hours, minutes, seconds, and
     * milliseconds.  Example: 13:43:46.671
     */
    LLTS_HHMMSSMS = 1,

    /**
     * Like above, plus date, e.g: 2017-03-21 13:43:46.671
     */
    LLTS_YYYYMMDD_HHMMSSMS = 2,

    /**
     * This is Chrome-like timestamp used by proto-quic.  The timestamp
     * includes month, date, hours, minutes, seconds, and microseconds.
     *
     * Example: 1223/104613.946956 (instead of 12/23 10:46:13.946956).
     *
     * This is to facilitate reading two logs side-by-side.
     */
    LLTS_CHROMELIKE = 3,

    /**
     * The timestamp consists of 24 hours, minutes, seconds, and
     * microseconds.  Example: 13:43:46.671123
     */
    LLTS_HHMMSSUS = 4,

    /**
     * Date and time using microsecond resolution,
     * e.g: 2017-03-21 13:43:46.671123
     */
    LLTS_YYYYMMDD_HHMMSSUS = 5,

    N_LLTS = 6;

/**
 * Call this if you want to do something with LSQUIC log messages, as they
 * are thrown out by default.
 */
public static native void lsquic_logger_init(@Const lsquic_logger_if arg0, Pointer logger_ctx,
                        @Cast("lsquic_logger_timestamp_style") int arg2);

/**
 * Set log level for all LSQUIC modules.  Acceptable values are debug, info,
 * notice, warning, error, alert, emerg, crit (case-insensitive).
 *
 * \retval  0   Success.
 * \retval -1   Failure: log_level is not valid.
 */
public static native int lsquic_set_log_level(@Cast("const char*") BytePointer log_level);
public static native int lsquic_set_log_level(String log_level);

/**
 * E.g. "event=debug"
 */
public static native int lsquic_logger_lopt(@Cast("const char*") BytePointer optarg);
public static native int lsquic_logger_lopt(String optarg);

/**
 * Return the list of QUIC versions (as bitmask) this engine instance
 * supports.
 */
public static native @Cast("unsigned") int lsquic_engine_quic_versions(@Const lsquic_engine_t arg0);

/**
 * This is one of the flags that can be passed to \ref lsquic_global_init.
 * Use it to initialize LSQUIC for use in client mode.
 */
public static final int LSQUIC_GLOBAL_CLIENT = (1 << 0);

/**
 * This is one of the flags that can be passed to \ref lsquic_global_init.
 * Use it to initialize LSQUIC for use in server mode.
 */
public static final int LSQUIC_GLOBAL_SERVER = (1 << 1);

/**
 * Initialize LSQUIC.  This must be called before any other LSQUIC function
 * is called.  Returns 0 on success and -1 on failure.
 *
 * @param flags     This a bitmask of \ref LSQUIC_GLOBAL_CLIENT and
 *                    \ref LSQUIC_GLOBAL_SERVER.  At least one of these
 *                    flags should be specified.
 *
 * \retval  0   Success.
 * \retval -1   Initialization failed.
 *
 * @see LSQUIC_GLOBAL_CLIENT
 * @see LSQUIC_GLOBAL_SERVER
 */
public static native int lsquic_global_init(int flags);

/**
 * Clean up global state created by \ref lsquic_global_init.  Should be
 * called after all LSQUIC engine instances are gone.
 */
public static native void lsquic_global_cleanup();

/**
 * Get QUIC version used by the connection.
 *
 * @see lsquic_version
 */
public static native @Cast("lsquic_version") int lsquic_conn_quic_version(@Const lsquic_conn_t c);

/* Return keysize or -1 on error */
public static native int lsquic_conn_crypto_keysize(@Const lsquic_conn_t c);

/* Return algorithm keysize or -1 on error */
public static native int lsquic_conn_crypto_alg_keysize(@Const lsquic_conn_t c);

/** enum lsquic_crypto_ver */
public static final int
    LSQ_CRY_QUIC = 0,
    LSQ_CRY_TLSv13 = 1;

public static native @Cast("lsquic_crypto_ver") int lsquic_conn_crypto_ver(@Const lsquic_conn_t c);

/* Return cipher or NULL on error */
public static native @Cast("const char*") BytePointer lsquic_conn_crypto_cipher(@Const lsquic_conn_t c);

/** Translate string QUIC version to LSQUIC QUIC version representation */
public static native @Cast("lsquic_version") int lsquic_str2ver(@Cast("const char*") BytePointer str, @Cast("size_t") long len);
public static native @Cast("lsquic_version") int lsquic_str2ver(String str, @Cast("size_t") long len);

/** Translate ALPN (e.g. "h3", "h3-23", "h3-Q046") to LSQUIC enum */
public static native @Cast("lsquic_version") int lsquic_alpn2ver(@Cast("const char*") BytePointer alpn, @Cast("size_t") long len);
public static native @Cast("lsquic_version") int lsquic_alpn2ver(String alpn, @Cast("size_t") long len);

/**
 * This function closes all mini connections and marks all full connections
 * as going away.  In server mode, this also causes the engine to stop
 * creating new connections.
 */
public static native void lsquic_engine_cooldown(lsquic_engine_t arg0);

/**
 * Get user-supplied context associated with the connection.
 */
public static native lsquic_conn_ctx_t lsquic_conn_get_ctx(@Const lsquic_conn_t arg0);

/**
 * Set user-supplied context associated with the connection.
 */
public static native void lsquic_conn_set_ctx(lsquic_conn_t arg0, lsquic_conn_ctx_t arg1);

/**
 * Get peer context associated with the connection.
 */
public static native Pointer lsquic_conn_get_peer_ctx(lsquic_conn_t arg0, @Const sockaddr local_sa);

/** Get SNI sent by the client */
public static native @Cast("const char*") BytePointer lsquic_conn_get_sni(lsquic_conn_t arg0);

/**
 * Abort connection.
 */
public static native void lsquic_conn_abort(lsquic_conn_t arg0);

/**
 * Helper function: convert list of versions as specified in the argument
 * bitmask to string that can be included as argument to "v=" part of the
 * Alt-Svc header.
 *
 * For example (1<<LSQVER_037)|(1<<LSQVER_038) => "37,38"
 *
 * This is only applicable to Google QUIC versions.
 */
public static native @Cast("const char*") BytePointer lsquic_get_alt_svc_versions(@Cast("unsigned") int versions);

/**
 * Return a NULL-terminated list of HTTP/3 ALPNs, e.g "h3-17", "h3-18", "h3".
 */
public static native @Cast("const char*const*") PointerPointer lsquic_get_h3_alpns(@Cast("unsigned") int versions);

/**
 * Returns true if provided buffer could be a valid handshake-stage packet,
 * false otherwise.  Do not call this function if a connection has already
 * been established: it will return incorrect result.
 */
public static native int lsquic_is_valid_hs_packet(lsquic_engine_t arg0, @Cast("const unsigned char*") BytePointer arg1, @Cast("size_t") long arg2);
public static native int lsquic_is_valid_hs_packet(lsquic_engine_t arg0, @Cast("const unsigned char*") ByteBuffer arg1, @Cast("size_t") long arg2);
public static native int lsquic_is_valid_hs_packet(lsquic_engine_t arg0, @Cast("const unsigned char*") byte[] arg1, @Cast("size_t") long arg2);

/**
 * Parse cid from packet stored in {@code buf' and store it to }cid'.  Returns 0
 * on success and -1 on failure.
 */
public static native int lsquic_cid_from_packet(@Cast("const unsigned char*") BytePointer arg0, @Cast("size_t") long bufsz, lsquic_cid_t cid);
public static native int lsquic_cid_from_packet(@Cast("const unsigned char*") ByteBuffer arg0, @Cast("size_t") long bufsz, lsquic_cid_t cid);
public static native int lsquic_cid_from_packet(@Cast("const unsigned char*") byte[] arg0, @Cast("size_t") long bufsz, lsquic_cid_t cid);

/**
 * Returns true if there are connections to be processed, false otherwise.
 * If true, {@code diff' is set to the difference between the earliest advisory
 * tick time and now.  If the former is in the past, the value of }diff'
 * is negative.
 */
public static native int lsquic_engine_earliest_adv_tick(lsquic_engine_t engine, IntPointer diff);
public static native int lsquic_engine_earliest_adv_tick(lsquic_engine_t engine, IntBuffer diff);
public static native int lsquic_engine_earliest_adv_tick(lsquic_engine_t engine, int[] diff);

/**
 * Return number of connections whose advisory tick time is before current
 * time plus {@code from_now' microseconds from now.  }from_now' can be negative.
 */
public static native @Cast("unsigned") int lsquic_engine_count_attq(lsquic_engine_t engine, int from_now);

/** enum LSQUIC_CONN_STATUS */
public static final int
    LSCONN_ST_HSK_IN_PROGRESS = 0,
    LSCONN_ST_CONNECTED = 1,
    LSCONN_ST_HSK_FAILURE = 2,
    LSCONN_ST_GOING_AWAY = 3,
    LSCONN_ST_TIMED_OUT = 4,
    /* If es_honor_prst is not set, the connection will never get public
     * reset packets and this flag will not be set.
     */
    LSCONN_ST_RESET = 5,
    LSCONN_ST_USER_ABORTED = 6,
    LSCONN_ST_ERROR = 7,
    LSCONN_ST_CLOSED = 8,
    LSCONN_ST_PEER_GOING_AWAY = 9;

public static native @Cast("LSQUIC_CONN_STATUS") int lsquic_conn_status(lsquic_conn_t arg0, @Cast("char*") BytePointer errbuf, @Cast("size_t") long bufsz);
public static native @Cast("LSQUIC_CONN_STATUS") int lsquic_conn_status(lsquic_conn_t arg0, @Cast("char*") ByteBuffer errbuf, @Cast("size_t") long bufsz);
public static native @Cast("LSQUIC_CONN_STATUS") int lsquic_conn_status(lsquic_conn_t arg0, @Cast("char*") byte[] errbuf, @Cast("size_t") long bufsz);

@MemberGetter public static native @Cast("const char*") BytePointer lsquic_ver2str(int i);
@MemberGetter public static native @Cast("const char*const*") PointerPointer lsquic_ver2str();

/* Return connection associated with this SSL object */
public static native lsquic_conn_t lsquic_ssl_to_conn(@Const ssl_st arg0);

// #ifdef __cplusplus
// #endif

// #endif //__LSQUIC_H__



}
